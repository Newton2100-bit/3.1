<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Leak Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin: 0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.1);
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }
        
        .title {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .memory-system {
            display: flex;
            gap: 30px;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }
        
        .memory-section {
            flex: 1;
            min-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .memory-section h3 {
            margin-top: 0;
            color: #ffd700;
            font-size: 1.3em;
        }
        
        .memory-pool {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }
        
        .memory-block {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }
        
        .memory-free {
            background: #4CAF50;
            border: 2px solid #45a049;
        }
        
        .memory-used {
            background: #2196F3;
            border: 2px solid #0b7dda;
        }
        
        .memory-leaked {
            background: #f44336;
            border: 2px solid #da190b;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .control-panel {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn-allocate {
            background: linear-gradient(45deg, #2196F3, #21CBF3);
            color: white;
        }
        
        .btn-free {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }
        
        .btn-leak {
            background: linear-gradient(45deg, #f44336, #da190b);
            color: white;
        }
        
        .btn-reset {
            background: linear-gradient(45deg, #FF9800, #F57C00);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            display: block;
            margin-bottom: 10px;
        }
        
        .code-example {
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            border-left: 4px solid #ffd700;
        }
        
        .explanation {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #4CAF50;
        }
        
        .warning {
            background: rgba(255, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #f44336;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="title">üß† Memory Leak Visualization</h1>
        
        <div class="memory-system">
            <div class="memory-section">
                <h3>System Memory Pool</h3>
                <div class="memory-pool" id="memoryPool"></div>
                <div class="control-panel">
                    <button class="btn btn-allocate" onclick="allocateMemory()">Allocate Memory</button>
                    <button class="btn btn-free" onclick="freeMemory()">Free Memory</button>
                    <button class="btn btn-leak" onclick="createLeak()">Create Leak</button>
                    <button class="btn btn-reset" onclick="resetMemory()">Reset</button>
                </div>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <span class="stat-number" id="freeMemory" style="color: #4CAF50;">64</span>
                <span>Free Blocks</span>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="usedMemory" style="color: #2196F3;">0</span>
                <span>Used Blocks</span>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="leakedMemory" style="color: #f44336;">0</span>
                <span>Leaked Blocks</span>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="memoryUsage" style="color: #ffd700;">0%</span>
                <span>Memory Usage</span>
            </div>
        </div>
        
        <div class="explanation">
            <h3>üìö What is a Memory Leak?</h3>
            <p>A memory leak occurs when a program allocates memory but fails to release it back to the system. Over time, this causes the program to consume more and more memory until the system runs out of available memory.</p>
            
            <h4>üîç How it works:</h4>
            <ul>
                <li><strong style="color: #4CAF50;">Green blocks</strong> = Free memory available to the system</li>
                <li><strong style="color: #2196F3;">Blue blocks</strong> = Memory properly allocated and still in use</li>
                <li><strong style="color: #f44336;">Red blocks</strong> = Leaked memory (allocated but lost reference)</li>
            </ul>
        </div>
        
        <div class="code-example">
            <h4>üêõ Common Memory Leak Example (C++):</h4>
            <pre>
void memoryLeakExample() {
    while (true) {
        int* ptr = new int[1000];  // Allocate memory
        // ‚ùå Missing: delete[] ptr;  // Never freed!
        
        // Pointer goes out of scope, memory is leaked
    }
}

‚úÖ Correct version:
void properMemoryManagement() {
    while (true) {
        int* ptr = new int[1000];  // Allocate memory
        // ... use the memory ...
        delete[] ptr;              // Free memory
        ptr = nullptr;             // Good practice
    }
}
            </pre>
        </div>
        
        <div class="warning">
            <h4>‚ö†Ô∏è Consequences of Memory Leaks:</h4>
            <ul>
                <li>System becomes slow and unresponsive</li>
                <li>Programs crash with "Out of Memory" errors</li>
                <li>System may need to be restarted</li>
                <li>Other programs can't allocate memory</li>
            </ul>
        </div>
        
        <div class="explanation">
            <h4>üõ†Ô∏è How to Prevent Memory Leaks:</h4>
            <ul>
                <li><strong>Always pair allocations with deallocations</strong> (malloc/free, new/delete)</li>
                <li><strong>Use smart pointers</strong> in C++ (unique_ptr, shared_ptr)</li>
                <li><strong>Use memory profilers</strong> like Valgrind, AddressSanitizer</li>
                <li><strong>Follow RAII principles</strong> (Resource Acquisition Is Initialization)</li>
                <li><strong>Use garbage-collected languages</strong> when appropriate (Java, Python, C#)</li>
            </ul>
        </div>
    </div>

    <script>
        let memoryBlocks = [];
        let allocatedBlocks = [];
        let leakedBlocks = [];
        const TOTAL_BLOCKS = 64;
        
        function initializeMemory() {
            const memoryPool = document.getElementById('memoryPool');
            memoryPool.innerHTML = '';
            memoryBlocks = [];
            allocatedBlocks = [];
            leakedBlocks = [];
            
            for (let i = 0; i < TOTAL_BLOCKS; i++) {
                const block = document.createElement('div');
                block.className = 'memory-block memory-free';
                block.id = `block-${i}`;
                block.textContent = i;
                memoryPool.appendChild(block);
                memoryBlocks.push({
                    id: i,
                    status: 'free',
                    element: block
                });
            }
            updateStats();
        }
        
        function allocateMemory() {
            const freeBlocks = memoryBlocks.filter(block => block.status === 'free');
            if (freeBlocks.length === 0) {
                alert('‚ö†Ô∏è Out of Memory! No free blocks available.');
                return;
            }
            
            const randomCount = Math.min(Math.floor(Math.random() * 5) + 1, freeBlocks.length);
            const blocksToAllocate = freeBlocks.slice(0, randomCount);
            
            blocksToAllocate.forEach(block => {
                block.status = 'used';
                block.element.className = 'memory-block memory-used';
                allocatedBlocks.push(block);
            });
            
            updateStats();
        }
        
        function freeMemory() {
            if (allocatedBlocks.length === 0) {
                alert('‚ÑπÔ∏è No allocated memory to free!');
                return;
            }
            
            const randomCount = Math.min(Math.floor(Math.random() * 3) + 1, allocatedBlocks.length);
            const blocksToFree = allocatedBlocks.splice(0, randomCount);
            
            blocksToFree.forEach(block => {
                block.status = 'free';
                block.element.className = 'memory-block memory-free';
            });
            
            updateStats();
        }
        
        function createLeak() {
            if (allocatedBlocks.length === 0) {
                alert('‚ÑπÔ∏è No allocated memory to leak! Allocate some memory first.');
                return;
            }
            
            const randomCount = Math.min(Math.floor(Math.random() * 2) + 1, allocatedBlocks.length);
            const blocksToLeak = allocatedBlocks.splice(0, randomCount);
            
            blocksToLeak.forEach(block => {
                block.status = 'leaked';
                block.element.className = 'memory-block memory-leaked';
                leakedBlocks.push(block);
            });
            
            updateStats();
            
            if (leakedBlocks.length > 10) {
                alert('üö® Critical Memory Leak! System performance degraded!');
            }
        }
        
        function resetMemory() {
            allocatedBlocks = [];
            leakedBlocks = [];
            memoryBlocks.forEach(block => {
                block.status = 'free';
                block.element.className = 'memory-block memory-free';
            });
            updateStats();
        }
        
        function updateStats() {
            const freeCount = memoryBlocks.filter(block => block.status === 'free').length;
            const usedCount = allocatedBlocks.length;
            const leakedCount = leakedBlocks.length;
            const usagePercentage = Math.round(((usedCount + leakedCount) / TOTAL_BLOCKS) * 100);
            
            document.getElementById('freeMemory').textContent = freeCount;
            document.getElementById('usedMemory').textContent = usedCount;
            document.getElementById('leakedMemory').textContent = leakedCount;
            document.getElementById('memoryUsage').textContent = usagePercentage + '%';
            
            // Change color based on usage
            const usageElement = document.getElementById('memoryUsage');
            if (usagePercentage < 50) {
                usageElement.style.color = '#4CAF50';
            } else if (usagePercentage < 80) {
                usageElement.style.color = '#FF9800';
            } else {
                usageElement.style.color = '#f44336';
            }
        }
        
        // Initialize the memory system
        initializeMemory();
        
        // Simulate automatic memory operations
        setInterval(() => {
            if (Math.random() < 0.3) {
                allocateMemory();
            }
            if (Math.random() < 0.2) {
                freeMemory();
            }
            if (Math.random() < 0.1) {
                createLeak();
            }
        }, 3000);
    </script>
</body>
</html>
